{
    "columns":[
        "abstract",
        "title",
        "author",
        "pub_year",
        "author_pub_id",
        "num_citations",
        "pub_url",
        "cites_id",
        "citedby_url",
        "cites_per_year"
    ],
    "index":[
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
    ],
    "data":[
        [
            "1.1 What Is Object-Oriented?, 1 1.2 What Is Object-Oriented Development?, 4 1.3 Object-Oriented \nThemes, 7 1.4 Evidence for Usefulness of Object-Oriented Development, 9 1.5 Organization \nof this Book, 10 Bibliographic Notes, 12 References, 12 Exercises, 13 \u2026 Part 1: Modeling Concepts \nCHAPTER 2 MODELING AS A DESIGN TECHNIQUE \u2026 2.1 Modeling, 15 2.2 The Object Modeling \nTechnique, 16 2.3 Chapter Summary, 19 Exercises, 19 CHAPTER 3 OBJECT MODELING \u2026 \n3.1 Objects and Classes, 21 3.2 Links and Associations, 27 3.3 Advanced Link and Association \nConcepts, 31 3.4 Generalization and Inheritance, 38 3.5 Grouping Constructs, 43 - 3.6 A Sample \nObject Model, 43 3.7 Practical Tips, 46 \u2026 3.8 Chapter Summary, 47 Bibliographic Notes, 48 \nReferences, 48 Exercises, 49 CHAPTER 4 ADVANCED OBJECT MODELING \u2026 4.1 \nAggregation, 57 4.2 Abstract Classes, 61 4.3 Generalization as Extension and \u2026 ",
            "Object-oriented modeling and design",
            "James Rumbaugh and Michael Blaha and William Premerlani and Frederick Eddy and William E.  Lorensen",
            "1991",
            "80pKMyMAAAAJ:FiytvqdAVhgC",
            11955,
            "https:\/\/www.academia.edu\/download\/33995975\/179841076.pdf",
            "18084469665172872971",
            "\/scholar?cites=18084469665172872971",
            {
                "1991":33,
                "1992":173,
                "1993":287,
                "1994":479,
                "1995":711,
                "1996":886,
                "1997":1048,
                "1998":1032,
                "1999":888,
                "2000":789,
                "2001":626,
                "2002":556,
                "2003":458,
                "2004":433,
                "2005":385,
                "2006":286,
                "2007":349,
                "2008":260,
                "2009":248,
                "2010":242,
                "2011":229,
                "2012":219,
                "2013":231,
                "2014":158,
                "2015":134,
                "2016":135,
                "2017":105,
                "2018":106,
                "2019":68,
                "2020":65,
                "2021":12
            }
        ],
        [
            "[Aho et al. 1979] Alfred V. Aho, Catriel Beeri, Jeffrey D. Ullman: The Theory of Joins in Relational \nDatabases. ACM Trans. Database Syst. 4(3): 297-314(1979) BibTeX [Aho et al. 1974] Alfred \nV. Aho, John E. Hopcroft, Jeffrey D. Ullman: The Design and Analysis of Computer \nAlgorithms. Addison-Wesley 1974, ISBN 0-201-00029-6 BibTeX [Aho et al. 1979] Alfred V. \nAho, Yehoshua Sagiv, Thomas G. Szymanski, Jeffrey D. Ullman: Inferring a Tree from Lowest \nCommon Ancestors with an Application to the Optimization of Relational Expressions. SIAM \nJ. Comput. 10(3): 405-421(1981) BibTeX [Aho et al. 1979a] Alfred V. Aho, Yehoshua Sagiv, Jeffrey \nD. Ullman: Efficient Optimization of a Class of Relational Expressions. ACM Trans. Database \nSyst. 4(4): 435-454(1979) BibTeX [Aho et al \u2026  ",
            "Theory of relational databases",
            "David Maier",
            "1983",
            "80pKMyMAAAAJ:u5HHmVD_uO8C",
            2423,
            "http:\/\/www.sigmod.org\/publications\/dblp\/db\/books\/dbtext\/Maier83.html",
            "4973853228543375519",
            "\/scholar?cites=4973853228543375519",
            {
                "1984":29,
                "1985":30,
                "1986":54,
                "1987":68,
                "1988":80,
                "1989":88,
                "1990":83,
                "1991":73,
                "1992":91,
                "1993":87,
                "1994":95,
                "1995":70,
                "1996":62,
                "1997":54,
                "1998":51,
                "1999":54,
                "2000":55,
                "2001":55,
                "2002":55,
                "2003":40,
                "2004":54,
                "2005":68,
                "2006":83,
                "2007":74,
                "2008":63,
                "2009":62,
                "2010":53,
                "2011":61,
                "2012":92,
                "2013":76,
                "2014":85,
                "2015":53,
                "2016":65,
                "2017":66,
                "2018":64,
                "2019":47,
                "2020":30,
                "2021":1
            }
        ],
        [
            "This paper presents a systematic solution to the persistent problem of buffer overflow attacks. Buffer overflow attacks gained notoriety in 1988 as part of the Morris Worm incident on the Internet. While it is fairly simple to fix individual buffer overflow vulnerabilities, buffer overflow attacks continue to this day. Hundreds of attacks have been discovered, and while most of the obvious vulnerabilities have now been patched, more sophisticated buffer overflow attacks continue to emerge.We describe StackGuard: a simple compiler technique that virtually eliminates buffer overflow vulnerabilities with only modest performance penalties. Privileged programs that are recompiled with the StackGuard compiler extension no longer yield control to the attacker, but rather enter a fail-safe state. These programs require no source code changes at all, and are binary-compatible with existing operating systems and libraries. We \u2026",
            "Stackguard: automatic adaptive detection and prevention of buffer-overflow attacks.",
            "Crispan Cowan and Calton Pu and Dave Maier and Jonathan Walpole and Peat Bakke and Steve Beattie and Aaron Grier and Perry Wagle and Qian Zhang and Heather Hinton",
            "1998",
            "80pKMyMAAAAJ:zCSUwVk65WsC",
            2081,
            "https:\/\/www.usenix.org\/publications\/library\/proceedings\/sec98\/full_papers\/cowan\/cowan.pdf",
            "11123853022422999285",
            "\/scholar?cites=11123853022422999285",
            {
                "1998":10,
                "1999":18,
                "2000":33,
                "2001":33,
                "2002":53,
                "2003":65,
                "2004":93,
                "2005":151,
                "2006":147,
                "2007":118,
                "2008":129,
                "2009":102,
                "2010":107,
                "2011":109,
                "2012":86,
                "2013":105,
                "2014":96,
                "2015":114,
                "2016":107,
                "2017":96,
                "2018":94,
                "2019":92,
                "2020":92,
                "2021":3
            }
        ],
        [
            "This paper attempts to define an object-oriented database system. It describes the main features and characteristics that a system must have to qualify as an object-oriented database system.We have separated these characteristics into three groups: \u2022Mandatory, the ones the system must satisfy in order to be termed an object-oriented database system. These are complex objects, object identity, encapsulation, types or classes, inheritance, overriding combined with late binding, extensibility, computational completeness, persistence, secondary storage management, concurrency, recovery and an ad hoc query facility.\u2022Optional, the ones that can be added to make the system better, but which are not mandatory. These are multiple inheritance, type checking and inferencing, distribution, design transactions and versions.\u2022Open, the points where the designer can make a number of choices. These are the programming \u2026Mandatory, the ones the system must satisfy in order to be termed an object-oriented database system. These are complex objects, object identity, encapsulation, types or classes, inheritance, overriding combined with late binding, extensibility, computational completeness, persistence, secondary storage management, concurrency, recovery and an ad hoc query facility.Optional, the ones that can be added to make the system better, but which are not mandatory. These are multiple inheritance, type checking and inferencing, distribution, design transactions and versions.Open, the points where the designer can make a number of choices. These are the programming \u2026",
            "The object-oriented database system manifesto",
            "Malcolm Atkinson and David Dewitt and David Maier and Francois Bancilhon and Klaus Dittrich and Stanley Zdonik",
            "1990",
            "80pKMyMAAAAJ:u-x6o8ySG0sC",
            1803,
            "https:\/\/www.sciencedirect.com\/science\/article\/pii\/B9780444884336500204",
            "15672558384095872074",
            "\/scholar?cites=15672558384095872074",
            {
                "1990":46,
                "1991":139,
                "1992":135,
                "1993":160,
                "1994":135,
                "1995":137,
                "1996":100,
                "1997":76,
                "1998":72,
                "1999":56,
                "2000":65,
                "2001":45,
                "2002":36,
                "2003":46,
                "2004":39,
                "2005":35,
                "2006":45,
                "2007":51,
                "2008":25,
                "2009":32,
                "2010":29,
                "2011":24,
                "2012":43,
                "2013":41,
                "2014":30,
                "2015":24,
                "2016":19,
                "2017":19,
                "2018":12,
                "2019":10,
                "2020":12,
                "2021":2
            }
        ],
        [
            "Several methods for implementing database queries expressed as logical rules are given and they are compared for efficiency. One method, called \u201cmagic sets,\u201d is a general algorithm for rewriting logical rules so that they may be implemented bottom-UP (= forward chaining) in a way that cuts down on the irrelevant facts that are generated. The advantage of this scheme is that by working bottom-up, we can take advantage of efficient methods for doing massive joins. Two other methods are ad hoc ways of implementing \u201clinear\u201d rules, ie, rules where at most one predicate in any body is recursive. These methods are",
            "Magic sets and other strange ways to implement logic programs",
            "Francois Bancilhon and David Maier and Yehoshua Sagiv and Jeffrey D Ullman",
            "1985",
            "80pKMyMAAAAJ:d1gkVwhDpl0C",
            1060,
            "https:\/\/dl.acm.org\/doi\/pdf\/10.1145\/6012.15399",
            "12972664209333316768",
            "\/scholar?cites=12972664209333316768",
            {
                "1986":12,
                "1987":20,
                "1988":40,
                "1989":46,
                "1990":53,
                "1991":50,
                "1992":48,
                "1993":56,
                "1994":61,
                "1995":51,
                "1996":43,
                "1997":31,
                "1998":29,
                "1999":19,
                "2000":19,
                "2001":12,
                "2002":20,
                "2003":23,
                "2004":12,
                "2005":14,
                "2006":20,
                "2007":26,
                "2008":32,
                "2009":40,
                "2010":25,
                "2011":35,
                "2012":38,
                "2013":26,
                "2014":25,
                "2015":22,
                "2016":23,
                "2017":19,
                "2018":16,
                "2019":15,
                "2020":17
            }
        ],
        [
            "The development of relational database management systems served to focus the data management community for decades, with spectacular results. In recent years, however, the rapidly-expanding demands of \"data everywhere\" have led to a field comprised of interesting and productive efforts, but without a central focus or coordinated agenda. The most acute information management challenges today stem from organizations (e.g., enterprises, government agencies, libraries, \"smart\" homes) relying on a large number of diverse, interrelated data sources, but having no way to manage their dataspaces in a convenient, integrated, or principled fashion. This paper proposes dataspaces and their support systems as a new agenda for data management. This agenda encompasses much of the work going on in data management today, while posing additional research objectives.",
            "From databases to dataspaces: a new abstraction for information management",
            "Michael Franklin and Alon Halevy and David Maier",
            "2005",
            "80pKMyMAAAAJ:Tyk-4Ss8FVUC",
            951,
            "https:\/\/dl.acm.org\/doi\/abs\/10.1145\/1107499.1107502",
            "11473686877002175313",
            "\/scholar?cites=11473686877002175313",
            {
                "2004":5,
                "2005":3,
                "2006":26,
                "2007":55,
                "2008":72,
                "2009":77,
                "2010":82,
                "2011":72,
                "2012":91,
                "2013":90,
                "2014":85,
                "2015":64,
                "2016":74,
                "2017":43,
                "2018":43,
                "2019":27,
                "2020":21
            }
        ],
        [
            "A class of database schemes, called acychc, was recently introduced. It is shown that this class has a number of desirable properties. In particular, several desirable properties that have been studied by other researchers m very different terms are all shown to be eqmvalent to acydicity. In addition, several equivalent charactenzauons of the class m terms of graphs and hypergraphs are given, and a smaple algorithm for determining acychclty is presented. Also given are several eqmvalent characterizations of those sets M of multivalued dependencies such that M is the set of muRlvalued dependencies that are the consequences of a given join dependency. Several characterizations for a conflict-free (in the sense of Lien) set of muluvalued dependencies are provided.",
            "On the desirability of acyclic database schemes",
            "Catriel Beeri and Ronald Fagin and David Maier and Mihalis Yannakakis",
            "1983",
            "80pKMyMAAAAJ:9yKSN-GCB0IC",
            935,
            "https:\/\/dl.acm.org\/doi\/abs\/10.1145\/2402.322389",
            "5881722332065135753",
            "\/scholar?cites=5881722332065135753",
            {
                "1982":3,
                "1983":16,
                "1984":26,
                "1985":13,
                "1986":15,
                "1987":24,
                "1988":21,
                "1989":26,
                "1990":15,
                "1991":19,
                "1992":12,
                "1993":21,
                "1994":31,
                "1995":19,
                "1996":14,
                "1997":19,
                "1998":19,
                "1999":13,
                "2000":17,
                "2001":21,
                "2002":27,
                "2003":22,
                "2004":20,
                "2005":24,
                "2006":37,
                "2007":20,
                "2008":30,
                "2009":38,
                "2010":27,
                "2011":26,
                "2012":40,
                "2013":58,
                "2014":31,
                "2015":33,
                "2016":19,
                "2017":21,
                "2018":19,
                "2019":26,
                "2020":33,
                "2021":1
            }
        ],
        [
            "The complexity of finding the Longest Common Subsequence (LCS) and the Shortest Common Supersequence (SCS) of an arbRrary number of sequences IS considered We show that the yes\/no version of the LCS problem is NP-complete for sequences over an alphabet of size 2, and that the yes\/no SCS problem is NP-complete for sequences over an alphabet of size 5",
            "The complexity of some problems on subsequences and supersequences",
            "David Maier",
            "1978",
            "80pKMyMAAAAJ:zYLM7Y9cAGgC",
            683,
            "https:\/\/dl.acm.org\/doi\/pdf\/10.1145\/322063.322075",
            "10212781357442568847",
            "\/scholar?cites=10212781357442568847",
            {
                "1982":4,
                "1983":3,
                "1984":2,
                "1985":5,
                "1986":2,
                "1987":5,
                "1988":2,
                "1989":7,
                "1990":2,
                "1991":3,
                "1992":16,
                "1993":11,
                "1994":17,
                "1995":13,
                "1996":9,
                "1997":4,
                "1998":15,
                "1999":8,
                "2000":17,
                "2001":10,
                "2002":12,
                "2003":16,
                "2004":11,
                "2005":18,
                "2006":13,
                "2007":28,
                "2008":31,
                "2009":22,
                "2010":41,
                "2011":30,
                "2012":29,
                "2013":35,
                "2014":32,
                "2015":35,
                "2016":30,
                "2017":28,
                "2018":32,
                "2019":28,
                "2020":35,
                "2021":3
            }
        ],
        [
            "We describe the results of developing the GemStone object-oriented database server, which supports a model of objects similar to that of Smalltalk-80. We begin with a summary of the goals and requirements for the system: an extensible data model that captures behavioral semantics, no artificial bounds on the number or size of database objects, database amenities (concurrency, transactions, recovery, associative access, authorization) and an interactive development environment. Object-oriented languages, Smalltalk in particular, answer some of these requirements. We discuss satisfying the remaining requirements in an object oriented context, and report briefly on the status of the development efforts. This paper is directed at an audience familiar with object-oriented languages and their implementation, but perhaps unacquainted with the difficulties and techniques of database system development. It updates \u2026",
            "Development of an object-oriented DBMS",
            "David Maier and Jacob Stein and Allen Otis and Alan Purdy",
            "1986",
            "80pKMyMAAAAJ:2osOgNQ5qMEC",
            635,
            "https:\/\/dl.acm.org\/doi\/abs\/10.1145\/960112.28746",
            "105911596539194748",
            "\/scholar?cites=105911596539194748",
            {
                "1986":4,
                "1987":27,
                "1988":46,
                "1989":68,
                "1990":78,
                "1991":79,
                "1992":57,
                "1993":75,
                "1994":33,
                "1995":24,
                "1996":26,
                "1997":10,
                "1998":10,
                "1999":12,
                "2000":12,
                "2001":5,
                "2002":4,
                "2003":1,
                "2004":3,
                "2005":2,
                "2006":4,
                "2007":5,
                "2008":1,
                "2009":3,
                "2010":8,
                "2011":4,
                "2012":5,
                "2013":6,
                "2014":3,
                "2015":4,
                "2016":4,
                "2017":2,
                "2018":1,
                "2019":1
            }
        ],
        [
            "Presented is a computation method\u2014the chase\u2014for testing implication of data dependencies by a set of data dependencies. The chase operates on tableaux similar to those of Aho, Sagiv, and Ullman. The chase includes previous tableau computation methods as special cases. By interpreting tableaux alternately as mappings or as templates for relations, it is possible to test implication of join dependencies (including multivalued dependencies) and functional dependencies by a set of dependencies.",
            "Testing implications of data dependencies",
            "David Maier and Alberto O Mendelzon and Yehoshua Sagiv",
            "1979",
            "80pKMyMAAAAJ:IjCSPb-OGe4C",
            626,
            "https:\/\/dl.acm.org\/doi\/abs\/10.1145\/320107.320115",
            "16302740402243589418",
            "\/scholar?cites=16302740402243589418",
            {
                "1982":21,
                "1983":29,
                "1984":24,
                "1985":13,
                "1986":10,
                "1987":10,
                "1988":11,
                "1989":11,
                "1990":7,
                "1991":12,
                "1992":12,
                "1993":7,
                "1994":5,
                "1995":6,
                "1996":2,
                "1997":6,
                "1998":6,
                "1999":11,
                "2000":6,
                "2001":10,
                "2002":4,
                "2003":11,
                "2004":7,
                "2005":8,
                "2006":13,
                "2007":10,
                "2008":14,
                "2009":18,
                "2010":29,
                "2011":34,
                "2012":37,
                "2013":34,
                "2014":32,
                "2015":19,
                "2016":20,
                "2017":14,
                "2018":26,
                "2019":20,
                "2020":16,
                "2021":1
            }
        ]
    ]
}